<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<style>

</style>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script type="text/javascript">
function draw(geo_data) {

  /* SETUP SVG OBJECT */

  "use strict";
  var margin = 75,
      width = 1920 - margin,
      height = 1080 - margin;
  
  var svg = d3.select("body")
    .append("svg")
    .attr("width", width + margin)
    .attr("height", height + margin)
    .append('g')
    .attr('class','map');

  /* SETUP D3 MAP */

  /*  works similiar to scale function:
      - input are coordinates
      - output are x and y values */
  var projection = d3.geo.mercator()
    .scale(170) // zoom factor
    .translate([width/2, height/2]); // position center of map
  
  // construct svg path objects to render projected pixels
  var path = d3.geo.path().projection(projection);
  
  var map = svg.selectAll('path')
    .data(geo_data.features)
    .enter()
    .append('path')
    .attr('d', path)
    .style('fill', 'rgb(9, 157, 217)')
    .style('stroke', 'black')
    .style('stroke-width', 0.5);

  /* SETUP CIRCLES IN MAP */
  
  function plot_points(data) {
    
    // group and aggregate data needed to draw circles
    var nested = d3.nest()
      // group all games by year
      .key(function(d) {
        return d['date'].getUTCFullYear();
      })
      // aggregate desired data for all games of a year
      .rollup(function(leaves) {
        // calculate total attendance
        var total = d3.sum(leaves, function(d) {
          return d['attendance'];
        });
        
        // calculate coordinates mean
        var coords = leaves.map(function(d) {
          return projection([+d.long, +d.lat]);
        });
        var center_x = d3.mean(coords, function(d) {
          return d[0];
        });
        var center_y = d3.mean(coords, function(d) {
          return d[1];
        });
        
        // create object that's returned
        return {
          'attendance': total,
          'x': center_x,
          'y': center_y
        };
      })
      // pass all data elements to keys and rollup functions
      .entries(data);
    
    
    /*  setup radius of circles
        it's important to not use the data values themselves as radius,
        but their square root */
    var attendance_max = d3.max(nested, function(d) {
      return d.values.attendance;
    });
    
    var radius = d3.scale.sqrt()
      .domain([0, attendance_max])
      .range([0, 12]);
    
    svg.append('g')
      .attr('class', 'bubble')
      .selectAll('circle')
      // sort data so that smaller circles are drawn on top of bigger circles
      .data(nested.sort(function(a, b) {
        return b.values.attendance - a.values.attendance;
      }))
      .enter()
      .append('circle')
      .attr('cx', function(d) {
        return d.values.x;
      })
      .attr('cy', function(d) {
        return d.values.y;
      })
      .attr('r', function(d) {
        return radius(d.values.attendance);
      })
      .attr('fill', 'rgb(247,148,32)')
      .attr('stroke', 'black')
      .attr('stroke-width', 0.7)
      .attr('opacity', 0.7);
  }
  
  var format = d3.time.format('%d-%m-%Y (%H:%M h)');
  
  d3.tsv('world_cup_geo.tsv', function(d) {
    d['attendance'] = +d['attendance'];
    d['date'] = format.parse(d['date']);
    return d;
  }, plot_points);

};
</script>
</head>
<body>
<script type="text/javascript">
/*
  Use D3 (not dimple.js) to load the TSV file
  and pass the contents of it to the draw function
  */

d3.json("world_countries.json", draw);
</script>
</body>
</html>
